# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401
r"""
Voice receive primitives for discord-ext-songbird.

This module provides sink-based APIs to consume decoded PCM audio from voice
connections. The primary entry point is `BufferSink`.

Classes
-------
BufferSink
    Buffering sink that yields `VoiceTick` snapshots.
StreamSink
    Streaming sink that yields `VoiceTick` snapshots.
Stream
    Async stream handle returned by `StreamSink.stream()`.
VoiceTick
    Per-tick snapshot of speaking and silent sources.
VoiceKey
    Identifier for a voice source (user ID or SSRC).
SinkBase
    Internal sink base class.

Examples
--------
```python
from discord.ext import songbird
from discord.ext.songbird import receive

vc = await channel.connect(cls=songbird.SongbirdClient)
sink = receive.BufferSink(max_duration_secs=5)
vc.listen(sink)

async for tick in sink:
    pcm = tick.get(receive.VoiceKey.User(user_id))
    if pcm is not None:
        handle_pcm(pcm)
```

Notes
-----
PCM is returned as `pyarrow.Int16Array`. Use `VoiceTick.is_silent()` to
distinguish silent from missing keys.
"""

import builtins
import typing

import pyarrow
from discord.ext.songbird.native.model import PyAsyncIterator

@typing.final
class BufferSink(SinkBase):
    r"""
    Buffering sink for received voice data.

    Collects `VoiceTick` snapshots and exposes them via async iteration.

    Examples
    --------
    ```python
    from discord.ext import songbird
    from discord.ext.songbird import receive

    vc = await channel.connect(cls=songbird.SongbirdClient)
    sink = receive.BufferSink(max_duration_secs=5)
    vc.listen(sink)

    async for tick in sink:
        pcm = tick.get(receive.VoiceKey.User(user_id))
        if pcm is not None:
            handle_pcm(pcm)
    ```
    """
    def __new__(
        cls, *, max_duration_secs: typing.Optional[builtins.int] = None, drop_oldest: builtins.bool = True
    ) -> typing.Self:
        r"""
        Create a new BufferSink.

        Parameters
        ----------
        max_duration_secs : int | None
            Maximum buffer size in seconds worth of ticks. If None, unbounded.
        drop_oldest : bool, optional
            If True, drop the oldest ticks when the buffer is full. If False,
            drop new ticks instead.

        Notes
        -----
        Internally converted to a tick count based on 20 ms per tick (50 ticks/sec).
        Parameters are keyword-only.

        Returns
        -------
        BufferSink
        """
    def stop(self) -> None:
        r"""
        Stop buffering new ticks.

        Notes
        -----
        This does not unregister the sink.

        Returns
        -------
        None
        """
    def __getitem__(self, key: VoiceKey) -> PyAsyncIterator[typing.Optional[pyarrow.Int16Array]]:
        r"""
        Return an async iterator over PCM for a specific key.

        Parameters
        ----------
        key : VoiceKey
            The user/ssrc key to filter.

        Returns
        -------
        PyAsyncIterator[pyarrow.Int16Array | None]

        Examples
        --------
        ```python
        key = receive.VoiceKey.User(user_id)
        async for pcm in sink[key]:
            if pcm is not None:
                handle_pcm(pcm)
        ```
        """
    def __aiter__(self) -> PyAsyncIterator[VoiceTick]:
        r"""
        Return an async iterator over buffered `VoiceTick` entries.

        Returns
        -------
        PyAsyncIterator[VoiceTick]

        Examples
        --------
        ```python
        async for tick in sink:
            ...
        ```
        """

class SinkBase:
    r"""
    Base class for receive sinks.

    Notes
    -----
    This is an internal type exposed to Python for sink registration.
    Custom sinks are not currently supported from Python.
    """

    ...

@typing.final
class Stream:
    r"""
    Async stream handle returned by `StreamSink.stream()`.

    This object is an async context manager that acquires a stream permit.
    """
    def close(self) -> typing.Coroutine[typing.Any, typing.Any, None]:
        r"""
        Close the stream and release its permit.

        Returns
        -------
        None
        """
    def __aenter__(self) -> typing.Coroutine[typing.Any, typing.Any, Stream]:
        r"""
        Enter the async context and acquire a stream permit.

        Returns
        -------
        Stream
        """
    def __aiter__(self) -> PyAsyncIterator[VoiceTick]:
        r"""
        Return an async iterator over `VoiceTick` entries.

        Returns
        -------
        PyAsyncIterator[VoiceTick]
        """
    def __aexit__(
        self, _exc_type: typing.Any, _exc_val: typing.Any, _exc_tb: typing.Any
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        r"""
        Exit the async context and release the stream permit.

        Returns
        -------
        None
        """
    def __getitem__(self, key: VoiceKey) -> PyAsyncIterator[typing.Optional[pyarrow.Int16Array]]:
        r"""
        Return an async iterator over PCM for a specific key.

        Parameters
        ----------
        key : VoiceKey
            The user/ssrc key to filter.

        Returns
        -------
        PyAsyncIterator[pyarrow.Int16Array | None]

        Examples
        --------
        ```python
        async with sink.stream() as stream:
            async for pcm in stream[receive.VoiceKey.User(user_id)]:
                if pcm is not None:
                    handle_pcm(pcm)
        ```
        """

@typing.final
class StreamSink(SinkBase):
    r"""
    Streaming sink for received voice data.

    Unlike `BufferSink`, this sink exposes a stream interface backed by a
    broadcast channel and supports concurrent consumers via permits.

    Examples
    --------
    ```python
    from discord.ext import songbird
    from discord.ext.songbird import receive

    vc = await channel.connect(cls=songbird.SongbirdClient)
    sink = receive.StreamSink()
    vc.listen(sink)

    async with sink.stream() as stream:
        async for tick in stream:
            ...
    ```
    """
    def __new__(
        cls, *, retain: builtins.bool = False, retain_secs: builtins.int = 15, max_concurrent: builtins.int = 50
    ) -> typing.Self:
        r"""
        Create a new StreamSink.

        Parameters
        ----------
        retain : bool, optional
            If True, ticks are retained even when no streams are active.
        retain_secs : int, optional
            Retention window in seconds for the broadcast buffer.
            Internally converted to a tick count based on 20 ms per tick (50 ticks/sec).
        max_concurrent : int, optional
            Maximum number of concurrent streams.

        Returns
        -------
        StreamSink
        """
    def stream(self) -> Stream:
        r"""
        Create an async stream handle.

        Use this with `async with` to acquire a stream permit.

        Returns
        -------
        Stream

        Examples
        --------
        ```python
        async with sink.stream() as stream:
            async for tick in stream:
                ...
        ```
        """

class VoiceKey:
    r"""
    Identifier for a voice source.

    This is either a Discord user ID or an unknown SSRC.

    Examples
    --------
    ```python
    key = receive.VoiceKey.User(1234)
    key.id()
    key.is_user()
    ```
    """
    def id(self) -> int:
        r"""
        Return the underlying integer identifier.

        For user keys this is the user ID, otherwise the SSRC value.

        Returns
        -------
        int

        Examples
        --------
        ```python
        key = receive.VoiceKey.User(1234)
        key.id()
        ```
        """
    def is_user(self) -> builtins.bool:
        r"""
        Check whether this key represents a user ID.

        Returns
        -------
        bool

        Examples
        --------
        ```python
        receive.VoiceKey.User(1).is_user()
        ```
        """
    def is_unknown(self) -> builtins.bool:
        r"""
        Check whether this key represents an unknown SSRC.

        Returns
        -------
        bool

        Examples
        --------
        ```python
        receive.VoiceKey.Unknown(42).is_unknown()
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Return a debug representation.

        Returns
        -------
        str
        """
    @typing.final
    class User(VoiceKey):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0: builtins.int) -> VoiceKey.User: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    @typing.final
    class Unknown(VoiceKey):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0: builtins.int) -> VoiceKey.Unknown: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

@typing.final
class VoiceTick:
    r"""
    Snapshot of received voice data for a single tick.

    Examples
    --------
    ```python
    key = receive.VoiceKey.User(user_id)
    pcm = tick.get(key)
    if pcm is None and tick.is_silent(key):
        print(\"silent\")
    ```
    """
    def get(self, key: VoiceKey) -> typing.Optional[pyarrow.Int16Array]:
        r"""
        Get PCM audio for a key if it is speaking in this tick.

        Parameters
        ----------
        key : VoiceKey
            The user/ssrc key to query.

        Returns
        -------
        pyarrow.Int16Array | None
            PCM when speaking, otherwise None.

        Examples
        --------
        ```python
        pcm = tick.get(receive.VoiceKey.User(user_id))
        if pcm is not None:
            handle_pcm(pcm)
        ```
        """
    def is_silent(self, key: VoiceKey) -> builtins.bool:
        r"""
        Check whether a key is marked silent in this tick.

        Parameters
        ----------
        key : VoiceKey
            The user/ssrc key to query.

        Returns
        -------
        bool

        Examples
        --------
        ```python
        if tick.is_silent(receive.VoiceKey.User(user_id)):
            ...
        ```
        """
    def all_keys(self) -> builtins.set[VoiceKey]:
        r"""
        Return all keys present in this tick (speaking + silent).

        Returns
        -------
        set[VoiceKey]

        Examples
        --------
        ```python
        for key in tick.all_keys():
            ...
        ```
        """
    def speaking_keys(self) -> builtins.set[VoiceKey]:
        r"""
        Return keys that have PCM data in this tick.

        Returns
        -------
        set[VoiceKey]

        Examples
        --------
        ```python
        for key in tick.speaking_keys():
            ...
        ```
        """
    def silent_keys(self) -> builtins.set[VoiceKey]:
        r"""
        Return keys marked silent in this tick.

        Returns
        -------
        set[VoiceKey]

        Examples
        --------
        ```python
        for key in tick.silent_keys():
            ...
        ```
        """
